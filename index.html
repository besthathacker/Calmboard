<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CalmBoard - 50+ Sounds</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #121212;
      color: #eee;
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      font-weight: 700;
      font-size: 2.5rem;
      margin-bottom: 15px;
    }
    #soundControls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      max-width: 1000px;
      margin-bottom: 30px;
      width: 100%;
    }
    .sound-control {
      background: #1e1e1e;
      border-radius: 10px;
      padding: 10px 15px;
      width: 180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      box-shadow: 0 3px 8px rgba(0,0,0,0.5);
      user-select: none;
    }
    .sound-name {
      margin-bottom: 8px;
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      height: 36px;
      overflow: hidden;
    }
    button.play-btn {
      background-color: #4caf50;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      font-size: 1.5rem;
      color: white;
      cursor: pointer;
      margin-bottom: 10px;
      transition: background-color 0.3s ease;
    }
    button.play-btn.paused {
      background-color: #f44336;
    }
    button.play-btn:focus {
      outline: none;
      box-shadow: 0 0 5px #4caf50;
    }
    input[type="range"] {
      width: 100%;
      -webkit-appearance: none;
      height: 8px;
      border-radius: 5px;
      background: #555;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #4caf50;
      cursor: pointer;
      border: none;
      margin-top: -5px;
      transition: background-color 0.3s ease;
    }
    input[type="range"]:focus::-webkit-slider-thumb {
      background: #81c784;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-bottom: 40px;
      max-width: 1000px;
      width: 100%;
    }
    #controls button {
      background-color: #2196f3;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      color: white;
      font-size: 1rem;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.3s ease;
    }
    #controls button:hover {
      background-color: #1769aa;
    }
    #recordStatus {
      text-align: center;
      font-weight: 600;
      font-size: 1.1rem;
      margin-top: 10px;
      min-height: 22px;
    }
    footer {
      margin-top: auto;
      padding: 12px 0;
      color: #777;
      font-size: 14px;
      user-select: none;
    }
  </style>
</head>
<body>
  <h1>CalmBoard</h1>

  <div id="soundControls"></div>

  <div id="controls">
    <button id="muteAllBtn">Mute All üîá</button>
    <button id="stopAllBtn">Stop All ‚èπÔ∏è</button>
    <button id="saveStateBtn">Save State üíæ</button>
    <button id="loadStateBtn">Load State üìÇ</button>
    <button id="startRecBtn">Start Recording üéôÔ∏è</button>
    <button id="stopRecBtn" disabled>Stop Recording ‚èπÔ∏è</button>
  </div>
  <div id="recordStatus"></div>

  <footer>Made With ‚ù§Ô∏è By Aiden</footer>

  <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
  <script>
    (async () => {
      const soundData = [
        {name: "Rain", url: "https://cdn.pixabay.com/download/audio/2021/08/04/audio_0a6a6e75ab.mp3?filename=rain-ambient-5514.mp3"},
        {name: "Ocean Waves", url: "https://cdn.pixabay.com/download/audio/2021/11/24/audio_0e7dcd82f1.mp3?filename=ocean-waves-10025.mp3"},
        {name: "Forest Night", url: "https://cdn.pixabay.com/download/audio/2022/03/23/audio_446e3e461e.mp3?filename=forest-night-12865.mp3"},
        {name: "Fireplace", url: "https://cdn.pixabay.com/download/audio/2022/02/07/audio_6f9a193ea9.mp3?filename=fireplace-12012.mp3"},
        {name: "Birds Chirping", url: "https://cdn.pixabay.com/download/audio/2021/09/02/audio_3f363d4915.mp3?filename=birds-7749.mp3"},
        {name: "Water Stream", url: "https://cdn.pixabay.com/download/audio/2021/09/07/audio_efb783b7e5.mp3?filename=stream-7950.mp3"},
        {name: "Wind Chimes", url: "https://cdn.pixabay.com/download/audio/2021/11/02/audio_0e44de06a3.mp3?filename=wind-chimes-9343.mp3"},
        {name: "Night Crickets", url: "https://cdn.pixabay.com/download/audio/2021/08/18/audio_5d4a0d56b0.mp3?filename=crickets-6697.mp3"},
        {name: "Thunderstorm", url: "https://cdn.pixabay.com/download/audio/2021/07/15/audio_c3f32c5b31.mp3?filename=thunderstorm-6291.mp3"},
        {name: "Gentle Breeze", url: "https://cdn.pixabay.com/download/audio/2021/10/16/audio_80d0f582c0.mp3?filename=gentle-wind-8624.mp3"},
        {name: "Meditation Bells", url: "https://cdn.pixabay.com/download/audio/2022/05/14/audio_3a33a5b715.mp3?filename=meditation-bells-13862.mp3"},
        {name: "Calm Ocean", url: "https://cdn.pixabay.com/download/audio/2022/03/10/audio_18c35bf5d8.mp3?filename=calm-ocean-12752.mp3"},
        {name: "Soft Piano", url: "https://cdn.pixabay.com/download/audio/2021/08/05/audio_19a9c2f5f5.mp3?filename=soft-piano-5533.mp3"},
        {name: "Rain on Tent", url: "https://cdn.pixabay.com/download/audio/2021/07/11/audio_118f1c5ec5.mp3?filename=rain-on-tent-6213.mp3"},
        {name: "Water Drops", url: "https://cdn.pixabay.com/download/audio/2022/01/25/audio_0a3e4cc006.mp3?filename=water-drops-11161.mp3"},
        {name: "River Flow", url: "https://cdn.pixabay.com/download/audio/2021/09/17/audio_00bc8d457d.mp3?filename=river-flow-8132.mp3"},
        {name: "Wind in Trees", url: "https://cdn.pixabay.com/download/audio/2022/01/31/audio_2163c81c8f.mp3?filename=wind-in-trees-11232.mp3"},
        {name: "Cave Drips", url: "https://cdn.pixabay.com/download/audio/2021/10/11/audio_9b01f7cc7e.mp3?filename=cave-drips-8495.mp3"},
        {name: "Waterfall", url: "https://cdn.pixabay.com/download/audio/2021/07/28/audio_6f29f9c4e4.mp3?filename=waterfall-6456.mp3"},
        {name: "Underwater", url: "https://cdn.pixabay.com/download/audio/2021/09/19/audio_f3d4dfb9bb.mp3?filename=underwater-8195.mp3"},
      ];

      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const masterGain = audioContext.createGain();
      masterGain.connect(audioContext.destination);

      const soundControlsDiv = document.getElementById('soundControls');
      const muteAllBtn = document.getElementById('muteAllBtn');
      const stopAllBtn = document.getElementById('stopAllBtn');
      const saveStateBtn = document.getElementById('saveStateBtn');
      const loadStateBtn = document.getElementById('loadStateBtn');
      const startRecBtn = document.getElementById('startRecBtn');
      const stopRecBtn = document.getElementById('stopRecBtn');
      const recordStatus = document.getElementById('recordStatus');

      let allSources = [];
      let allButtons = [];
      let allVolumes = [];

      // Unlock AudioContext on first user interaction (needed for iOS)
      async function unlockAudioContext() {
        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }
      }
      document.body.addEventListener('click', unlockAudioContext, {once: true});

      function createSoundControls({name, url}, index) {
        const container = document.createElement('div');
        container.className = 'sound-control';

        const label = document.createElement('div');
        label.className = 'sound-name';
        label.textContent = name;

        const btn = document.createElement('button');
        btn.className = 'play-btn';
        btn.title = `Play/Pause ${name}`;
        btn.textContent = '‚ñ∂Ô∏è';

        const vol = document.createElement('input');
        vol.type = 'range';
        vol.min = 0;
        vol.max = 1;
        vol.step = 0.01;
        vol.value = 0.5;

        container.appendChild(label);
        container.appendChild(btn);
        container.appendChild(vol);
        soundControlsDiv.appendChild(container);

        const audio = new Audio(url);
        audio.loop = true;
        const track = audioContext.createMediaElementSource(audio);
        const gainNode = audioContext.createGain();
        gainNode.gain.value = parseFloat(vol.value);
        track.connect(gainNode).connect(masterGain);

        allSources.push({audio, gainNode});
        allButtons.push(btn);
        allVolumes.push(vol);

        btn.addEventListener('click', async () => {
          await unlockAudioContext();
          try {
            if (audio.paused) {
              await audio.play();
              btn.textContent = '‚è∏Ô∏è';
              btn.classList.add('paused');
            } else {
              audio.pause();
              btn.textContent = '‚ñ∂Ô∏è';
              btn.classList.remove('paused');
            }
          } catch (e) {
            alert('Playback failed: ' + e.message);
          }
        });

        vol.addEventListener('input', () => {
          gainNode.gain.value = parseFloat(vol.value);
        });
      }

      soundData.forEach(createSoundControls);

      let isMuted = false;
      muteAllBtn.addEventListener('click', async () => {
        await unlockAudioContext();
        isMuted = !isMuted;
        masterGain.gain.value = isMuted ? 0 : 1;
        muteAllBtn.textContent = isMuted ? 'Unmute All üîä' : 'Mute All üîá';
      });

      stopAllBtn.addEventListener('click', async () => {
        await unlockAudioContext();
        allSources.forEach(({audio}, i) => {
          audio.pause();
          audio.currentTime = 0;
          allButtons[i].textContent = '‚ñ∂Ô∏è';
          allButtons[i].classList.remove('paused');
        });
      });

      saveStateBtn.addEventListener('click', () => {
        const state = allSources.map(({audio, gainNode}) => ({
          playing: !audio.paused,
          currentTime: audio.currentTime,
          volume: gainNode.gain.value
        }));
        localStorage.setItem('calmingSoundboardState', JSON.stringify(state));
        alert('State saved!');
      });

      loadStateBtn.addEventListener('click', async () => {
        await unlockAudioContext();
        const raw = localStorage.getItem('calmingSoundboardState');
        if (!raw) {
          alert('No saved state found.');
          return;
        }
        const state = JSON.parse(raw);
        for (let i = 0; i < state.length; i++) {
          const {playing, currentTime, volume} = state[i];
          const {audio, gainNode} = allSources[i];
          audio.currentTime = currentTime;
          gainNode.gain.value = volume;
          allVolumes[i].value = volume;
          if (playing) {
            try {
              await audio.play();
              allButtons[i].textContent = '‚è∏Ô∏è';
              allButtons[i].classList.add('paused');
            } catch {
              allButtons[i].textContent = '‚ñ∂Ô∏è';
              allButtons[i].classList.remove('paused');
            }
          } else {
            audio.pause();
            allButtons[i].textContent = '‚ñ∂Ô∏è';
            allButtons[i].classList.remove('paused');
          }
        }
      });

      const dest = audioContext.createMediaStreamDestination();
      masterGain.connect(dest);

      let mediaRecorder;
      let recordedChunks = [];

      startRecBtn.addEventListener('click', async () => {
        await unlockAudioContext();

        recordedChunks = [];
        mediaRecorder = new MediaRecorder(dest.stream, {mimeType: 'audio/webm'});

        mediaRecorder.ondataavailable = e => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstart = () => {
          recordStatus.textContent = 'Recording... üéôÔ∏è';
          startRecBtn.disabled = true;
          stopRecBtn.disabled = false;
        };

        mediaRecorder.onstop = async () => {
          recordStatus.textContent = 'Encoding MP3... ‚è≥';

          const webmBlob = new Blob(recordedChunks, {type: 'audio/webm'});
          const arrayBuffer = await webmBlob.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

          const mp3Blob = encodeMp3(audioBuffer);

          const url = URL.createObjectURL(mp3Blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'calmboard-recording.mp3';
          a.click();
          URL.revokeObjectURL(url);

          recordStatus.textContent = 'Recording saved as MP3 ‚úÖ';
          startRecBtn.disabled = false;
          stopRecBtn.disabled = true;
        };

        mediaRecorder.start();
      });

      stopRecBtn.addEventListener('click', () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          mediaRecorder.stop();
        }
      });

      function encodeMp3(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const mp3encoder = new lamejs.Mp3Encoder(numChannels, sampleRate, 128);

        const samples = [];
        for(let ch = 0; ch < numChannels; ch++) {
          samples.push(audioBuffer.getChannelData(ch));
        }

        const blockSize = 1152;
        const mp3Data = [];

        for (let i = 0; i < samples[0].length; i += blockSize) {
          const sampleChunk = [];
          for (let ch = 0; ch < numChannels; ch++) {
            sampleChunk[ch] = samples[ch].subarray(i, i + blockSize);
          }
          let mp3buf;
          if (numChannels === 1) {
            mp3buf = mp3encoder.encodeBuffer(floatTo16BitPCM(sampleChunk[0]));
          } else {
            mp3buf = mp3encoder.encodeBuffer(
              floatTo16BitPCM(sampleChunk[0]),
              floatTo16BitPCM(sampleChunk[1])
            );
          }
          if (mp3buf.length > 0) mp3Data.push(mp3buf);
        }
        const mp3buf = mp3encoder.flush();
        if (mp3buf.length > 0) mp3Data.push(mp3buf);

        return new Blob(mp3Data, {type: 'audio/mp3'});
      }

      function floatTo16BitPCM(input) {
        const output = new Int16Array(input.length);
        for (let i = 0; i < input.length; i++) {
          let s = Math.max(-1, Math.min(1, input[i]));
          output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        return output;
      }
    })();
  </script>
</body>
</html>
